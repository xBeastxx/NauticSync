var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// electron/services/profileService.ts
var profileService_exports = {};
__export(profileService_exports, {
  detectProfile: () => detectProfile,
  detectProfilesForFolders: () => detectProfilesForFolders
});
async function detectProfile(folderPath) {
  try {
    const files = await fs4.promises.readdir(folderPath);
    const fileSet = new Set(files);
    for (const profile of PROFILE_DETECTIONS) {
      for (const detectFile of profile.detectFiles) {
        if (fileSet.has(detectFile)) {
          console.log(`Detected ${profile.id} profile in ${folderPath} (found ${detectFile})`);
          return profile.id;
        }
      }
    }
    return "generic";
  } catch (error) {
    console.error(`Error detecting profile for ${folderPath}:`, error);
    return "generic";
  }
}
async function detectProfilesForFolders(folderPaths) {
  const results = {};
  for (const folderPath of folderPaths) {
    results[folderPath] = await detectProfile(folderPath);
  }
  return results;
}
var fs4, PROFILE_DETECTIONS;
var init_profileService = __esm({
  "electron/services/profileService.ts"() {
    fs4 = __toESM(require("fs"), 1);
    PROFILE_DETECTIONS = [
      { id: "node", detectFiles: ["package.json"] },
      { id: "python", detectFiles: ["requirements.txt", "pyproject.toml", "setup.py", "Pipfile"] },
      { id: "rust", detectFiles: ["Cargo.toml"] },
      { id: "go", detectFiles: ["go.mod"] }
    ];
  }
});

// electron/services/ignoreParser.ts
var ignoreParser_exports = {};
__export(ignoreParser_exports, {
  DEFAULT_STIGNORE_PATTERNS: () => DEFAULT_STIGNORE_PATTERNS,
  applyProfileIgnores: () => applyProfileIgnores,
  convertToStignore: () => convertToStignore,
  getStignore: () => getStignore,
  importGitignore: () => importGitignore,
  mergeIgnores: () => mergeIgnores,
  parseGitignore: () => parseGitignore,
  writeStignore: () => writeStignore
});
async function parseGitignore(folderPath) {
  const gitignorePath = path4.join(folderPath, ".gitignore");
  try {
    const content = await fs5.promises.readFile(gitignorePath, "utf-8");
    return content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
  } catch {
    return [];
  }
}
function convertToStignore(patterns) {
  return patterns.filter((p) => !p.startsWith("!")).map((pattern) => {
    return pattern;
  });
}
async function getStignore(folderPath) {
  const stignorePath = path4.join(folderPath, ".stignore");
  try {
    const content = await fs5.promises.readFile(stignorePath, "utf-8");
    return content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("//"));
  } catch {
    return [];
  }
}
async function writeStignore(folderPath, patterns) {
  const stignorePath = path4.join(folderPath, ".stignore");
  const header = "// Auto-generated by SyncMaster\n// https://docs.syncthing.net/users/ignoring.html\n\n";
  const content = header + patterns.join("\n") + "\n";
  await fs5.promises.writeFile(stignorePath, content, "utf-8");
}
async function mergeIgnores(folderPath, additionalPatterns) {
  const existing = await getStignore(folderPath);
  const converted = convertToStignore(additionalPatterns);
  const combined = [.../* @__PURE__ */ new Set([...DEFAULT_STIGNORE_PATTERNS, ...existing, ...converted])];
  await writeStignore(folderPath, combined);
  return combined;
}
async function importGitignore(folderPath) {
  const gitPatterns = await parseGitignore(folderPath);
  if (gitPatterns.length === 0) {
    return { imported: 0, total: 0 };
  }
  const merged = await mergeIgnores(folderPath, gitPatterns);
  return { imported: gitPatterns.length, total: merged.length };
}
async function applyProfileIgnores(folderPath, patterns) {
  const merged = await mergeIgnores(folderPath, patterns);
  return { applied: patterns.length, total: merged.length };
}
var fs5, path4, DEFAULT_STIGNORE_PATTERNS;
var init_ignoreParser = __esm({
  "electron/services/ignoreParser.ts"() {
    fs5 = __toESM(require("fs"), 1);
    path4 = __toESM(require("path"), 1);
    DEFAULT_STIGNORE_PATTERNS = [
      ".git",
      ".gitignore",
      "node_modules",
      ".DS_Store",
      "Thumbs.db",
      "*.sync-conflict-*"
      // Don't sync conflict files themselves
    ];
  }
});

// electron/services/mediaService.ts
var mediaService_exports = {};
__export(mediaService_exports, {
  findDuplicates: () => findDuplicates,
  hashFile: () => hashFile,
  scanMediaFiles: () => scanMediaFiles
});
async function scanMediaFiles(folderPath, ignorePatterns = []) {
  const results = [];
  async function scan(dir) {
    try {
      const entries = await fs6.promises.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path5.join(dir, entry.name);
        const relativePath = path5.relative(folderPath, fullPath);
        if (entry.name.startsWith(".") || entry.name === "node_modules" || entry.name === "__pycache__") {
          continue;
        }
        let isIgnored = false;
        try {
          const normalizedPath = relativePath.split(path5.sep).join("/");
          isIgnored = ignorePatterns.some((pattern) => {
            return minimatch(normalizedPath, pattern, { dot: true, matchBase: true });
          });
        } catch (err) {
          console.error("Error checking ignore pattern:", err);
        }
        if (entry.isDirectory()) {
          await scan(fullPath);
        } else if (entry.isFile()) {
          const ext = path5.extname(entry.name).toLowerCase();
          let type = null;
          if (IMAGE_EXTENSIONS.includes(ext)) {
            type = "image";
          } else if (VIDEO_EXTENSIONS.includes(ext)) {
            type = "video";
          } else if (AUDIO_EXTENSIONS.includes(ext)) {
            type = "audio";
          } else if (MODEL_EXTENSIONS.includes(ext)) {
            type = "model";
          }
          if (type) {
            try {
              const stats = await fs6.promises.stat(fullPath);
              results.push({
                id: Buffer.from(fullPath).toString("base64"),
                path: fullPath,
                name: entry.name,
                type,
                extension: ext,
                size: stats.size,
                modifiedTime: stats.mtime,
                isIgnored
                // Now correctly populated
              });
            } catch {
            }
          }
        }
      }
    } catch (error) {
      console.error(`Error scanning ${dir}:`, error);
    }
  }
  await scan(folderPath);
  return results;
}
async function hashFile(filePath) {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash("md5");
    const stream = fs6.createReadStream(filePath);
    stream.on("data", (data) => hash.update(data));
    stream.on("end", () => resolve(hash.digest("hex")));
    stream.on("error", reject);
  });
}
async function findDuplicates(files) {
  const hashMap = /* @__PURE__ */ new Map();
  for (const file of files) {
    try {
      const hash = await hashFile(file.path);
      if (!hashMap.has(hash)) {
        hashMap.set(hash, []);
      }
      hashMap.get(hash).push(file);
    } catch (error) {
      console.error(`Error hashing ${file.path}:`, error);
    }
  }
  const duplicates = /* @__PURE__ */ new Map();
  for (const [hash, files2] of hashMap) {
    if (files2.length > 1) {
      duplicates.set(hash, files2);
    }
  }
  return duplicates;
}
var fs6, path5, crypto, minimatch, IMAGE_EXTENSIONS, VIDEO_EXTENSIONS, AUDIO_EXTENSIONS, MODEL_EXTENSIONS;
var init_mediaService = __esm({
  "electron/services/mediaService.ts"() {
    fs6 = __toESM(require("fs"), 1);
    path5 = __toESM(require("path"), 1);
    crypto = __toESM(require("crypto"), 1);
    ({ minimatch } = require("minimatch"));
    IMAGE_EXTENSIONS = [".jpg", ".jpeg", ".png", ".gif", ".webp", ".bmp", ".svg", ".ico"];
    VIDEO_EXTENSIONS = [".mp4", ".webm", ".mov", ".avi", ".mkv", ".wmv", ".flv"];
    AUDIO_EXTENSIONS = [".mp3", ".wav", ".ogg", ".flac", ".m4a", ".aac", ".wma"];
    MODEL_EXTENSIONS = [".obj", ".fbx", ".glb", ".gltf", ".stl", ".blend", ".dae"];
  }
});

// electron/services/searchService.ts
var searchService_exports = {};
__export(searchService_exports, {
  searchFiles: () => searchFiles
});
async function searchFiles(folders, query, maxResults = 50) {
  if (!query || query.length < 2) return [];
  const results = [];
  const lowerQuery = query.toLowerCase();
  for (const folderPath of folders) {
    try {
      await searchDirectory(folderPath, folderPath, lowerQuery, results, maxResults);
      if (results.length >= maxResults) break;
    } catch (err) {
      console.error(`Failed to search ${folderPath}:`, err);
    }
  }
  results.sort((a, b) => {
    const aName = a.name.toLowerCase();
    const bName = b.name.toLowerCase();
    const aExact = aName === lowerQuery;
    const bExact = bName === lowerQuery;
    if (aExact && !bExact) return -1;
    if (bExact && !aExact) return 1;
    const aStarts = aName.startsWith(lowerQuery);
    const bStarts = bName.startsWith(lowerQuery);
    if (aStarts && !bStarts) return -1;
    if (bStarts && !aStarts) return 1;
    return 0;
  });
  return results.slice(0, maxResults);
}
async function searchDirectory(basePath, currentPath, query, results, maxResults) {
  if (results.length >= maxResults) return;
  try {
    const entries = await fs7.promises.readdir(currentPath, { withFileTypes: true });
    for (const entry of entries) {
      if (results.length >= maxResults) break;
      if (entry.name.startsWith(".") || entry.name === "node_modules" || entry.name === ".stversions" || entry.name.startsWith(".sync-")) {
        continue;
      }
      const fullPath = path6.join(currentPath, entry.name);
      const lowerName = entry.name.toLowerCase();
      if (lowerName.includes(query)) {
        try {
          const stats = await fs7.promises.stat(fullPath);
          results.push({
            name: entry.name,
            path: fullPath,
            type: entry.isDirectory() ? "folder" : "file",
            folder: path6.basename(basePath),
            size: entry.isFile() ? stats.size : void 0,
            modified: stats.mtimeMs
          });
        } catch {
        }
      }
      if (entry.isDirectory()) {
        const depth = fullPath.replace(basePath, "").split(path6.sep).length;
        if (depth < 5) {
          await searchDirectory(basePath, fullPath, query, results, maxResults);
        }
      }
    }
  } catch (err) {
  }
}
var fs7, path6;
var init_searchService = __esm({
  "electron/services/searchService.ts"() {
    fs7 = __toESM(require("fs"), 1);
    path6 = __toESM(require("path"), 1);
  }
});

// electron/services/conflictService.ts
var conflictService_exports = {};
__export(conflictService_exports, {
  resolveConflict: () => resolveConflict,
  scanConflicts: () => scanConflicts
});
async function scanConflicts(folders) {
  const conflictGroups = /* @__PURE__ */ new Map();
  for (const folder of folders) {
    try {
      await scanDirectoryForConflicts(folder, folder, conflictGroups);
    } catch (error) {
      console.error(`Failed to scan ${folder} for conflicts:`, error);
    }
  }
  return Array.from(conflictGroups.values());
}
async function scanDirectoryForConflicts(basePath, currentPath, groups) {
  const entries = await fs8.promises.readdir(currentPath, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path7.join(currentPath, entry.name);
    if (entry.isDirectory()) {
      if (entry.name.startsWith(".") || entry.name === "node_modules") continue;
      const depth = fullPath.replace(basePath, "").split(path7.sep).length;
      if (depth < 8) {
        await scanDirectoryForConflicts(basePath, fullPath, groups);
      }
      continue;
    }
    if (entry.name.includes(".sync-conflict-")) {
      try {
        const match = entry.name.match(/(.+)\.sync-conflict-(\d{8}-\d{6})-([^\.]+)(\..+)?$/);
        if (match) {
          const [_, baseName, dateStr, deviceId, ext] = match;
          const originalName = baseName + (ext || "");
          const originalPath = path7.join(currentPath, originalName);
          if (!groups.has(originalPath)) {
            groups.set(originalPath, {
              originalFile: originalName,
              originalPath,
              conflicts: []
            });
          }
          const stats = await fs8.promises.stat(fullPath);
          const group = groups.get(originalPath);
          const year = parseInt(dateStr.substring(0, 4));
          const month = parseInt(dateStr.substring(4, 6)) - 1;
          const day = parseInt(dateStr.substring(6, 8));
          const hour = parseInt(dateStr.substring(9, 11));
          const minute = parseInt(dateStr.substring(11, 13));
          const second = parseInt(dateStr.substring(13, 15));
          group.conflicts.push({
            path: fullPath,
            filename: entry.name,
            modified: stats.mtimeMs,
            size: stats.size,
            deviceId,
            date: new Date(year, month, day, hour, minute, second)
          });
        }
      } catch (err) {
        console.error(`Error processing conflict file ${entry.name}:`, err);
      }
    }
  }
}
async function resolveConflict(conflictPath, originalPath, strategy) {
  if (strategy === "keep-local") {
    await fs8.promises.unlink(conflictPath);
  } else if (strategy === "keep-remote") {
    await fs8.promises.copyFile(conflictPath, originalPath);
    await fs8.promises.unlink(conflictPath);
  }
}
var fs8, path7;
var init_conflictService = __esm({
  "electron/services/conflictService.ts"() {
    fs8 = __toESM(require("fs"), 1);
    path7 = __toESM(require("path"), 1);
  }
});

// electron/services/backupService.ts
var backupService_exports = {};
__export(backupService_exports, {
  getFileHistory: () => getFileHistory,
  getVersionedFiles: () => getVersionedFiles,
  moveToVersions: () => moveToVersions,
  restoreVersion: () => restoreVersion
});
function parseVersionTimestamp(filename) {
  const match = filename.match(VERSION_PATTERN);
  if (!match) return null;
  const [, baseName, timestampStr, ext = ""] = match;
  const year = parseInt(timestampStr.slice(0, 4));
  const month = parseInt(timestampStr.slice(4, 6)) - 1;
  const day = parseInt(timestampStr.slice(6, 8));
  const hour = parseInt(timestampStr.slice(9, 11));
  const minute = parseInt(timestampStr.slice(11, 13));
  const second = parseInt(timestampStr.slice(13, 15));
  return {
    originalName: baseName + ext,
    timestamp: new Date(year, month, day, hour, minute, second)
  };
}
async function getVersionedFiles(folderPath) {
  const versionsPath = path8.join(folderPath, ".stversions");
  const results = [];
  async function scan(dir, relativePath = "") {
    try {
      const entries = await fs9.promises.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path8.join(dir, entry.name);
        const relPath = path8.join(relativePath, entry.name);
        if (entry.isDirectory()) {
          await scan(fullPath, relPath);
        } else if (entry.isFile()) {
          const parsed = parseVersionTimestamp(entry.name);
          if (parsed) {
            try {
              const stats = await fs9.promises.stat(fullPath);
              results.push({
                id: Buffer.from(fullPath).toString("base64"),
                originalName: parsed.originalName,
                originalPath: path8.join(folderPath, relativePath, parsed.originalName),
                versionPath: fullPath,
                timestamp: parsed.timestamp,
                size: stats.size
              });
            } catch {
            }
          }
        }
      }
    } catch (error) {
      console.log(`No versions folder at ${dir}`);
    }
  }
  await scan(versionsPath);
  results.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
  return results;
}
async function restoreVersion(versionPath, originalPath) {
  try {
    const stats = await fs9.promises.stat(originalPath);
    if (stats.isFile()) {
      const backupPath = originalPath + ".backup";
      await fs9.promises.copyFile(originalPath, backupPath);
    }
  } catch {
  }
  await fs9.promises.copyFile(versionPath, originalPath);
  await fs9.promises.unlink(versionPath);
}
async function getFileHistory(folderPath, fileName) {
  const allVersions = await getVersionedFiles(folderPath);
  return allVersions.filter((v) => v.originalName === fileName);
}
function generateVersionTimestamp() {
  const now = /* @__PURE__ */ new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");
  return `${year}${month}${day}-${hours}${minutes}${seconds}`;
}
async function moveToVersions(filePath, folderPath) {
  const relativePath = path8.relative(folderPath, filePath);
  const dirName = path8.dirname(relativePath);
  const fileName = path8.basename(filePath);
  const ext = path8.extname(fileName);
  const baseName = path8.basename(fileName, ext);
  const timestamp = generateVersionTimestamp();
  const versionedName = `${baseName}~${timestamp}${ext}`;
  const versionsDir = path8.join(folderPath, ".stversions", dirName);
  await fs9.promises.mkdir(versionsDir, { recursive: true });
  const versionPath = path8.join(versionsDir, versionedName);
  await fs9.promises.copyFile(filePath, versionPath);
  console.log(`Backed up ${filePath} to ${versionPath}`);
  await fs9.promises.unlink(filePath);
}
var fs9, path8, VERSION_PATTERN;
var init_backupService = __esm({
  "electron/services/backupService.ts"() {
    fs9 = __toESM(require("fs"), 1);
    path8 = __toESM(require("path"), 1);
    VERSION_PATTERN = /^(.+)~(\d{8}-\d{6})(\.[^.]+)?$/;
  }
});

// electron/services/imports.ts
var imports_exports = {};
__export(imports_exports, {
  ImportsService: () => ImportsService
});
var import_fs4, import_path4, ImportsService;
var init_imports = __esm({
  "electron/services/imports.ts"() {
    import_fs4 = __toESM(require("fs"), 1);
    import_path4 = __toESM(require("path"), 1);
    ImportsService = class {
      async ensureImportsDir(projectPath) {
        const importsDir = import_path4.default.join(projectPath, ".imports");
        if (!import_fs4.default.existsSync(importsDir)) {
          import_fs4.default.mkdirSync(importsDir);
        }
        const gitignorePath = import_path4.default.join(projectPath, ".gitignore");
        if (import_fs4.default.existsSync(gitignorePath)) {
          const content = import_fs4.default.readFileSync(gitignorePath, "utf8");
          if (!content.includes(".imports/")) {
            import_fs4.default.appendFileSync(gitignorePath, "\n# MegaSync Imports\n.imports/\n");
          }
        } else {
          import_fs4.default.writeFileSync(gitignorePath, "# MegaSync Imports\n.imports/\n");
        }
        return importsDir;
      }
      async saveImport(projectPath, fileName, content, isBinary = false) {
        const importsDir = await this.ensureImportsDir(projectPath);
        const filePath = import_path4.default.join(importsDir, fileName);
        const fileDir = import_path4.default.dirname(filePath);
        if (!import_fs4.default.existsSync(fileDir)) {
          import_fs4.default.mkdirSync(fileDir, { recursive: true });
        }
        if (isBinary) {
          import_fs4.default.writeFileSync(filePath, content);
        } else {
          import_fs4.default.writeFileSync(filePath, content, "utf8");
        }
        return filePath;
      }
      // List immediate children of .imports/subPath
      async listImports(projectPath, subPath = "") {
        const importsDir = import_path4.default.join(projectPath, ".imports", subPath);
        if (!import_fs4.default.existsSync(importsDir)) return [];
        const dirStat = import_fs4.default.statSync(importsDir);
        if (!dirStat.isDirectory()) return [];
        const items = import_fs4.default.readdirSync(importsDir);
        const result = items.map((name) => {
          const fullPath = import_path4.default.join(importsDir, name);
          const stat = import_fs4.default.statSync(fullPath);
          const relativePath = import_path4.default.join(subPath, name).split(import_path4.default.sep).join("/");
          return {
            name,
            path: relativePath,
            fullPath,
            size: stat.size,
            updatedAt: stat.mtime,
            type: stat.isDirectory() ? "dir" : "file"
          };
        });
        return result.sort((a, b) => {
          if (a.type === b.type) return a.name.localeCompare(b.name);
          return a.type === "dir" ? -1 : 1;
        });
      }
      async readImport(projectPath, relativePath) {
        const target = import_path4.default.join(projectPath, ".imports", relativePath);
        if (import_fs4.default.existsSync(target)) {
          return import_fs4.default.readFileSync(target, "utf8");
        }
        throw new Error("File not found");
      }
      async deleteImport(projectPath, relativePath) {
        const target = import_path4.default.join(projectPath, ".imports", relativePath);
        if (import_fs4.default.existsSync(target)) {
          const stat = import_fs4.default.statSync(target);
          if (stat.isDirectory()) {
            import_fs4.default.rmSync(target, { recursive: true, force: true });
          } else {
            import_fs4.default.unlinkSync(target);
          }
          return true;
        }
        return false;
      }
      async promoteImport(projectPath, relativePath, destPath) {
        const source = import_path4.default.join(projectPath, ".imports", relativePath);
        const destination = import_path4.default.join(projectPath, destPath);
        const destDir = import_path4.default.dirname(destination);
        if (!import_fs4.default.existsSync(destDir)) {
          import_fs4.default.mkdirSync(destDir, { recursive: true });
        }
        import_fs4.default.renameSync(source, destination);
        return true;
      }
      async downloadImport(projectPath, fileName, url) {
        const importsDir = await this.ensureImportsDir(projectPath);
        const targetPath = import_path4.default.join(importsDir, fileName);
        const fileDir = import_path4.default.dirname(targetPath);
        if (!import_fs4.default.existsSync(fileDir)) {
          import_fs4.default.mkdirSync(fileDir, { recursive: true });
        }
        try {
          const axios2 = await import("axios");
          const fs11 = await import("fs");
          const response = await axios2.default({
            url,
            method: "GET",
            responseType: "stream"
          });
          const writer = fs11.createWriteStream(targetPath);
          response.data.pipe(writer);
          return new Promise((resolve, reject) => {
            writer.on("finish", () => resolve(targetPath));
            writer.on("error", reject);
          });
        } catch (error) {
          console.error("Import download failed:", error);
          throw error;
        }
      }
    };
  }
});

// electron/main.ts
var import_electron3 = require("electron");
var import_path5 = __toESM(require("path"), 1);

// electron/services/installer.ts
var import_fs = __toESM(require("fs"), 1);
var import_path = __toESM(require("path"), 1);
var import_axios = __toESM(require("axios"), 1);
var import_adm_zip = __toESM(require("adm-zip"), 1);
var import_electron = require("electron");
var SYNCTHING_VERSION = "v1.27.2";
var PLATFORM = "windows-amd64";
var BINARY_NAME = "syncthing.exe";
var DOWNLOAD_URL = `https://github.com/syncthing/syncthing/releases/download/${SYNCTHING_VERSION}/syncthing-${PLATFORM}-${SYNCTHING_VERSION}.zip`;
var SyncthingInstaller = class {
  binDir;
  exePath;
  constructor() {
    this.binDir = import_path.default.join(import_electron.app.getPath("userData"), "bin");
    this.exePath = import_path.default.join(this.binDir, BINARY_NAME);
  }
  async ensureInstalled() {
    if (this.isInstalled()) {
      console.log("Syncthing binary found at:", this.exePath);
      return this.exePath;
    }
    console.log("Syncthing binary not found. Starting download...");
    await this.downloadAndExtract();
    return this.exePath;
  }
  isInstalled() {
    return import_fs.default.existsSync(this.exePath);
  }
  async downloadAndExtract() {
    if (!import_fs.default.existsSync(this.binDir)) {
      import_fs.default.mkdirSync(this.binDir, { recursive: true });
    }
    const zipPath = import_path.default.join(this.binDir, "syncthing.zip");
    try {
      console.log(`Downloading from ${DOWNLOAD_URL}...`);
      const response = await (0, import_axios.default)({
        url: DOWNLOAD_URL,
        method: "GET",
        responseType: "arraybuffer"
      });
      import_fs.default.writeFileSync(zipPath, response.data);
      console.log("Download complete.");
      console.log("Extracting...");
      const zip = new import_adm_zip.default(zipPath);
      const zipEntries = zip.getEntries();
      zipEntries.forEach((entry) => {
        if (entry.entryName.endsWith(BINARY_NAME)) {
          const buffer = entry.getData();
          import_fs.default.writeFileSync(this.exePath, buffer);
        }
      });
      console.log("Extraction complete.");
      import_fs.default.unlinkSync(zipPath);
    } catch (error) {
      console.error("Failed to download syncthing:", error);
      throw error;
    }
  }
  getBinaryPath() {
    return this.exePath;
  }
};

// electron/services/runner.ts
var import_child_process = require("child_process");
var import_path2 = __toESM(require("path"), 1);
var import_electron2 = require("electron");
var import_fs2 = __toESM(require("fs"), 1);
var SyncthingRunner = class {
  child = null;
  binPath;
  apiKey = null;
  guiUrl = null;
  // Default config folder for syncthing
  configDir;
  constructor(binPath) {
    this.binPath = binPath;
    this.configDir = import_path2.default.join(import_electron2.app.getPath("userData"), "syncthing-config");
  }
  start() {
    return new Promise((resolve, reject) => {
      var _a, _b;
      console.log("Starting Syncthing from:", this.binPath);
      if (!import_fs2.default.existsSync(this.configDir)) {
        import_fs2.default.mkdirSync(this.configDir, { recursive: true });
      }
      this.readConfig();
      this.child = (0, import_child_process.spawn)(this.binPath, ["-home", this.configDir, "-no-browser", "-no-restart"], {
        stdio: "pipe"
      });
      this.child.on("error", (err) => {
        console.error("Syncthing process error:", err);
        reject(err);
      });
      (_a = this.child.stdout) == null ? void 0 : _a.on("data", (data) => {
        const output = data.toString();
        console.log("[Syncthing]", output.trim());
        if (output.includes("Ready to synchronize") || output.includes("is another Syncthing instance already running")) {
          this.readConfig();
          resolve();
        }
      });
      (_b = this.child.stderr) == null ? void 0 : _b.on("data", (data) => {
        console.error("[Syncthing Error]", data.toString());
      });
    });
  }
  stop() {
    if (this.child) {
      console.log("Stopping Syncthing...");
      this.child.kill();
      this.child = null;
    }
  }
  readConfig() {
    try {
      const configPath = import_path2.default.join(this.configDir, "config.xml");
      if (import_fs2.default.existsSync(configPath)) {
        const xml = import_fs2.default.readFileSync(configPath, "utf-8");
        const match = xml.match(/<apikey>(.*?)<\/apikey>/);
        if (match) {
          this.apiKey = match[1];
          console.log("Detected API Key:", this.apiKey);
        }
        const guiMatch = xml.match(/<gui[^>]*>[\s\S]*?<address>(.*?)<\/address>[\s\S]*?<\/gui>/);
        if (guiMatch) {
          this.guiUrl = "http://" + guiMatch[1];
        } else {
          const addrMatch = xml.match(/<address>([0-9.:]+)<\/address>/);
          if (addrMatch) {
            this.guiUrl = "http://" + addrMatch[1];
          }
        }
      }
    } catch (err) {
      console.error("Failed to read config.xml", err);
    }
  }
  getApiKey() {
    return this.apiKey;
  }
  getUrl() {
    return this.guiUrl || "http://127.0.0.1:8384";
  }
};

// electron/services/filesystem.ts
var import_fs3 = __toESM(require("fs"), 1);
var import_path3 = __toESM(require("path"), 1);
var FileSystemService = class {
  async readDirectory(dirPath) {
    try {
      if (!import_fs3.default.existsSync(dirPath)) {
        throw new Error(`Directory not found: ${dirPath}`);
      }
      const items = await import_fs3.default.promises.readdir(dirPath, { withFileTypes: true });
      const entries = items.map((item) => ({
        name: item.name,
        path: import_path3.default.join(dirPath, item.name),
        isDirectory: item.isDirectory()
      }));
      entries.sort((a, b) => {
        if (a.isDirectory === b.isDirectory) {
          return a.name.localeCompare(b.name);
        }
        return a.isDirectory ? -1 : 1;
      });
      return entries;
    } catch (error) {
      console.error("Failed to read directory:", error);
      throw error;
    }
  }
};

// electron/main.ts
var mainWindow = null;
var syncRunner = null;
var tray = null;
var createWindow = () => {
  mainWindow = new import_electron3.BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: import_path5.default.join(__dirname, "preload.cjs"),
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: false
      // Allow loading local file:// URLs for media
    },
    frame: false,
    // Custom frame for modern look
    backgroundColor: "#000000",
    show: false
    // Don't show until ready
  });
  const isDev = process.env.NODE_ENV === "development" || !import_electron3.app.isPackaged;
  if (isDev) {
    mainWindow.loadURL("http://localhost:5173");
    mainWindow.webContents.openDevTools();
  } else {
    mainWindow.loadFile(import_path5.default.join(__dirname, "../dist/index.html"));
  }
  mainWindow.once("ready-to-show", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    const installer = new SyncthingInstaller();
    installer.ensureInstalled().then(async (binPath) => {
      console.log("Syncthing binary ready at:", binPath);
      syncRunner = new SyncthingRunner(binPath);
      try {
        await syncRunner.start();
        console.log("Syncthing started successfully");
      } catch (err) {
        console.error("Failed to start Syncthing:", err);
      }
    }).catch((err) => {
      console.error("Failed to install Syncthing:", err);
    });
  });
};
var createTray = () => {
  const isDev = process.env.NODE_ENV === "development" || !import_electron3.app.isPackaged;
  const iconPath = isDev ? import_path5.default.join(__dirname, "../public/icon.ico") : import_path5.default.join(process.resourcesPath, "icon.ico");
  let trayIcon;
  try {
    trayIcon = import_electron3.nativeImage.createFromPath(iconPath);
    if (trayIcon.isEmpty()) {
      trayIcon = import_electron3.nativeImage.createEmpty();
    }
  } catch {
    trayIcon = import_electron3.nativeImage.createEmpty();
  }
  tray = new import_electron3.Tray(trayIcon.resize({ width: 16, height: 16 }));
  tray.setToolTip("NauticSync");
  const contextMenu = import_electron3.Menu.buildFromTemplate([
    {
      label: "Show NauticSync",
      click: () => {
        mainWindow == null ? void 0 : mainWindow.show();
        mainWindow == null ? void 0 : mainWindow.focus();
      }
    },
    { type: "separator" },
    {
      label: "Sync Status: Running",
      enabled: false
    },
    { type: "separator" },
    {
      label: "Quit",
      click: () => {
        import_electron3.app.quit();
      }
    }
  ]);
  tray.setContextMenu(contextMenu);
  tray.on("double-click", () => {
    mainWindow == null ? void 0 : mainWindow.show();
    mainWindow == null ? void 0 : mainWindow.focus();
  });
};
import_electron3.app.on("ready", async () => {
  createWindow();
  createTray();
  const fsService = new FileSystemService();
  import_electron3.ipcMain.handle("get-syncthing-config", () => {
    if (!syncRunner) return { apiKey: null, url: null };
    return {
      apiKey: syncRunner.getApiKey(),
      url: syncRunner.getUrl()
    };
  });
  import_electron3.ipcMain.handle("get-auto-start", () => {
    const settings = import_electron3.app.getLoginItemSettings();
    return settings.openAtLogin;
  });
  import_electron3.ipcMain.handle("set-auto-start", (event, enabled) => {
    import_electron3.app.setLoginItemSettings({
      openAtLogin: enabled,
      openAsHidden: false
    });
    return enabled;
  });
  import_electron3.ipcMain.handle("read-directory", async (event, dirPath) => {
    return await fsService.readDirectory(dirPath);
  });
  import_electron3.ipcMain.handle("detect-profile", async (event, folderPath) => {
    const { detectProfile: detectProfile2 } = await Promise.resolve().then(() => (init_profileService(), profileService_exports));
    return await detectProfile2(folderPath);
  });
  import_electron3.ipcMain.handle("import-gitignore", async (event, folderPath) => {
    const { importGitignore: importGitignore2 } = await Promise.resolve().then(() => (init_ignoreParser(), ignoreParser_exports));
    return await importGitignore2(folderPath);
  });
  import_electron3.ipcMain.handle("apply-profile-ignores", async (event, { folderPath, patterns }) => {
    const { applyProfileIgnores: applyProfileIgnores2 } = await Promise.resolve().then(() => (init_ignoreParser(), ignoreParser_exports));
    return await applyProfileIgnores2(folderPath, patterns);
  });
  import_electron3.ipcMain.handle("scan-media", async (event, { folderPath, ignorePatterns }) => {
    const { scanMediaFiles: scanMediaFiles2 } = await Promise.resolve().then(() => (init_mediaService(), mediaService_exports));
    return await scanMediaFiles2(folderPath, ignorePatterns);
  });
  import_electron3.ipcMain.handle("find-duplicates", async (event, folderPath) => {
    const { scanMediaFiles: scanMediaFiles2, findDuplicates: findDuplicates2 } = await Promise.resolve().then(() => (init_mediaService(), mediaService_exports));
    const files = await scanMediaFiles2(folderPath);
    const duplicates = await findDuplicates2(files);
    return Array.from(duplicates.values());
  });
  import_electron3.ipcMain.handle("search-files", async (event, { folders, query }) => {
    const { searchFiles: searchFiles2 } = await Promise.resolve().then(() => (init_searchService(), searchService_exports));
    return await searchFiles2(folders, query, 50);
  });
  import_electron3.ipcMain.handle("scan-conflicts", async (event, folders) => {
    const { scanConflicts: scanConflicts2 } = await Promise.resolve().then(() => (init_conflictService(), conflictService_exports));
    return await scanConflicts2(folders);
  });
  import_electron3.ipcMain.handle("resolve-conflict", async (event, { conflictPath, originalPath, strategy }) => {
    const { resolveConflict: resolveConflict2 } = await Promise.resolve().then(() => (init_conflictService(), conflictService_exports));
    return await resolveConflict2(conflictPath, originalPath, strategy);
  });
  import_electron3.ipcMain.handle("get-file-versions", async (event, folderPath) => {
    const { getVersionedFiles: getVersionedFiles2 } = await Promise.resolve().then(() => (init_backupService(), backupService_exports));
    return await getVersionedFiles2(folderPath);
  });
  import_electron3.ipcMain.handle("restore-file-version", async (event, { versionPath, originalPath }) => {
    const { restoreVersion: restoreVersion2 } = await Promise.resolve().then(() => (init_backupService(), backupService_exports));
    return await restoreVersion2(versionPath, originalPath);
  });
  import_electron3.ipcMain.handle("delete-file-version", async (event, versionPath) => {
    const fs11 = await import("fs");
    try {
      await fs11.promises.unlink(versionPath);
    } catch (e) {
      console.error("Failed to delete version:", e);
      throw e;
    }
  });
  import_electron3.ipcMain.handle("delete-file", async (event, filePath) => {
    const fs11 = await import("fs");
    await fs11.promises.unlink(filePath);
  });
  import_electron3.ipcMain.handle("delete-file-with-backup", async (event, { filePath, folderPath }) => {
    const { moveToVersions: moveToVersions2 } = await Promise.resolve().then(() => (init_backupService(), backupService_exports));
    await moveToVersions2(filePath, folderPath);
  });
  import_electron3.ipcMain.handle("read-file", async (_, filePath) => {
    try {
      const fs11 = await import("fs");
      await fs11.promises.access(filePath);
      const stats = await fs11.promises.stat(filePath);
      if (stats.size > 10 * 1024 * 1024) {
        throw new Error("File too large to preview");
      }
      const content = await fs11.promises.readFile(filePath, "utf-8");
      return content;
    } catch (error) {
      console.error("Failed to read file:", error);
      throw error;
    }
  });
  import_electron3.ipcMain.handle("write-file", async (_, { filePath, content }) => {
    try {
      const fs11 = await import("fs");
      await fs11.promises.writeFile(filePath, content, "utf-8");
    } catch (error) {
      console.error("Failed to write file:", error);
      throw error;
    }
  });
  import_electron3.ipcMain.handle("show-save-dialog", async (event, defaultName) => {
    const { dialog: dialog2 } = require("electron");
    const { filePath } = await dialog2.showSaveDialog(mainWindow, {
      defaultPath: defaultName,
      properties: ["createDirectory", "showOverwriteConfirmation"]
    });
    return filePath;
  });
  import_electron3.ipcMain.handle("open-path", async (event, pathStr) => {
    const { shell } = require("electron");
    const fs11 = await import("fs");
    try {
      const stats = await fs11.promises.stat(pathStr);
      if (stats.isFile()) {
        shell.showItemInFolder(pathStr);
        return;
      }
    } catch {
    }
    return await shell.openPath(pathStr);
  });
  import_electron3.ipcMain.handle("close-window", () => {
    mainWindow == null ? void 0 : mainWindow.close();
  });
  import_electron3.ipcMain.handle("minimize-window", () => {
    mainWindow == null ? void 0 : mainWindow.minimize();
  });
  import_electron3.ipcMain.handle("toggle-maximize-window", () => {
    if (!mainWindow) return;
    if (mainWindow.isFullScreen()) {
      mainWindow.setFullScreen(false);
    } else {
      mainWindow.setFullScreen(true);
    }
  });
  import_electron3.ipcMain.handle("list-imports", async (event, { projectPath, subPath }) => {
    const { ImportsService: ImportsService2 } = await Promise.resolve().then(() => (init_imports(), imports_exports));
    return await new ImportsService2().listImports(projectPath, subPath);
  });
  import_electron3.ipcMain.handle("read-import", async (event, { projectPath, relativePath }) => {
    const { ImportsService: ImportsService2 } = await Promise.resolve().then(() => (init_imports(), imports_exports));
    return await new ImportsService2().readImport(projectPath, relativePath);
  });
  import_electron3.ipcMain.handle("delete-import", async (event, { projectPath, relativePath }) => {
    const { ImportsService: ImportsService2 } = await Promise.resolve().then(() => (init_imports(), imports_exports));
    return await new ImportsService2().deleteImport(projectPath, relativePath);
  });
  import_electron3.ipcMain.handle("promote-import", async (event, { projectPath, relativePath, destPath }) => {
    const { ImportsService: ImportsService2 } = await Promise.resolve().then(() => (init_imports(), imports_exports));
    return await new ImportsService2().promoteImport(projectPath, relativePath, destPath);
  });
  import_electron3.ipcMain.handle("ensure-imports-dir", async (event, projectPath) => {
    const { ImportsService: ImportsService2 } = await Promise.resolve().then(() => (init_imports(), imports_exports));
    return await new ImportsService2().ensureImportsDir(projectPath);
  });
  import_electron3.ipcMain.handle("download-import", async (event, { projectPath, fileName, url }) => {
    const { ImportsService: ImportsService2 } = await Promise.resolve().then(() => (init_imports(), imports_exports));
    return await new ImportsService2().downloadImport(projectPath, fileName, url);
  });
  import_electron3.ipcMain.handle("open-directory", async () => {
    const { canceled, filePaths } = await import_electron3.dialog.showOpenDialog({
      properties: ["openDirectory"]
    });
    if (canceled) return null;
    return filePaths[0];
  });
});
import_electron3.app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    import_electron3.app.quit();
  }
});
import_electron3.app.on("will-quit", () => {
  if (syncRunner) {
    syncRunner.stop();
  }
});
import_electron3.app.on("activate", () => {
  if (import_electron3.BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
